[[toc|flat]]
----
=DASHBOARD= 
==En cours== 
==A faire== 
* Ecrire une xslt de vue et une xslt de media appelables successivement
* Trouver le moyen le plus simple d'appliquer une xslt à un xml
* Compléter le fichier de données avec la liste de mots en français
* Compléter le fichier de données avec la liste de mots en anglais
* Rédiger la xsd validant {{Data.xml}}
* Afficher les packages / classes sous forme de tableaux dans la section java
==Fait== 
* Gérer l'imbrication de code dans un tableau dans Wikispaces
* Rédiger : 
** les fichiers xml correspondant aux pages existantes sur PragmaticMemory.wikispaces
** les fichiers xslt de mise en page au format wikispaces

* Choix du lieu de stockage des fichiers de données (xml), styles (xslt) et schemas (xsd) 
** Wikispaces 
*** Avantages : 
**** Wiki gratuit pour un usage privé
*** Inconvénients : 
**** les versions des fichiers téléchargés dans Wikispaces ne peuvent pas être supprimées. Conséquence : la limite de taille risque d'être atteinte rapidement si les mises à jour sont fréquentes.
** Google Docs 
*** Avantages : 
**** Gratuit
*** Inconvénients : 
**** Site non accessible à partir du bureau
** Digiposte 
*** Avantages : 
**** Gratuit
**** Structure ayant plus de chance de durer que d'autre sites
*** Inconvénients : 
**** Pas de gestion de version : deux fichiers avec un nom identique sont stockés comme deux fichiers différents
** Solution retenue : Digiposte
* Séparer les données du formattage 
** Solution retenue : Utilation des xslt
* Séparer le formattage lié à la vue du formattage lié au media de diffusion 
** Solution retenue : Création de xslt de vue et de xslt de media
* Gérer les indentations de ligne de code
* Gérer le language (java, sql,...) dans la balise de code
----
=PRINCIPES DE REDACTION= 
L'objectif de cette section est de lister les principes permettant d'améliorer la forme du wiki, afin d'éliminer tout ce qui n'est pas indispensable ou qui peut minimiser la compréhension.
==Clarté== 
[[code]]
Entre deux formulations d'une même information, utiliser la plus claire.
[[code]]
* (à développer) Utiliser la mise en forme pour permettre une distinction des types d'information
==Homogénéité== 
[[code]]
Forme : utiliser la même forme pour transmettre un même type d'information.
[[code]]
* Règles à déterminer : 
** utilisation des temps (futur, présent, ...)
** utilisation de la casse (majuscule ou minuscule)
** ponctuation
[[code]]
Terme : utiliser toujours les mêmes termes pour désigner une même notion.
[[code]]
==Séparation== 
[[code]]
Distinguer les informations utiles (données à transmettre) de la mise en page (manière de transmettre les données).
[[code]]
* Il est ainsi possible d'avoir différentes vues d'un même ensemble de donnée.
* Les différentes vues peuvent être destinées : 
** à un rendu par différents outils (wikispaces, wikipedia, navigateur web, ...)
** à insiter sur différents aspects d'un ensemble de données au sein d'un même outil
* La mise en oeuvre de ce principe est faite par l'utilisation de fichiers xml et xslt.
* 3 types de fichiers sont utilisés : 
** un fichier de "données", d'extension xml, stockant les données utiles
** des fichiers "style", d'extension xslt, définissant chacun un style de présentation
** des fichiers "link", d'extension xml, chancun associant le fichier de données à un fichier de style 
*** [[code format="xml"]]
 <?xml version="1.0" encoding="UTF-8"?>
 <?xml-stylesheet href="StyleUrl" type="text/xsl" ?>
 <!DOCTYPE linkedData [<!ENTITY data SYSTEM "DataUrl">]>
 <linkedData>
 &data;
 </linkedData>
[[code]]
*** à remplacer dans le template (+ exemple dans le cas de Subversion): 
**** StyleUrl : adresse Wikispaces du fichier xslt (http://pragmaticmemory.wikispaces.com/file/view/SubversionWikispaces.xsl/353079998/SubversionWikispaces.xsl)
**** DataUrl : adresse Wikispaces du fichier xml (http://pragmaticmemory.wikispaces.com/file/view/Subversion.xml/353000074/Subversion.xml)
**** Exemple : dans le cas de la page Subversion, Wikispaces.xml associe le fichier de données de Data.xml à la feuille de style Wikispaces.xslt
* les fichiers xml doivent être encodés en UTF-8
* concernant les liens vers les pièces jointes Wikispaces contenant les versions de ces fichiers : 
** toute mise à jour du fichier de données nécessite la mise à jour de tous les fichiers de link
** toute mise à jour d'un fichier de vue nécessite la mise à jour du fichier link associé
==Concision== 
[[code]]
Taille : entre deux formulations aussi claire d'une même information, utiliser la plus courte, sauf si elle ne respecte pas le principe d'homogénéité
[[code]]
* Utiliser les formulations avec verbe plutôt que celles avec substantif : ces formulations sont généralement plus courtes. Même s'il exite des cas où elles sont plus longues, on les utilisera systématiquement au nom du principe d'homogénité. 
** par exemple : dire "Utiliser une variable" plutôt que "Utilisation d'une variable" (gain de 5 caratères)
** un contre-exemple : "Trier les lignes" plus long que "Tri de lignes" (3 caractères de plus)
* Utiliser les participes-présent plutôt que les subordonnées 
** "permettant" au lieu de "qui permettent" (gain de 4 caractères)
[[code]]
Factorisation : éliminer les redondances de mots ou de groupes de mots
[[code]]
* Eliminer les redondances d'informations d'un texte avec son titre (à développer)
* Principe des "code smell" 
** "code smell" de répétition de mot 
*** La liste : 
**** Principes d'homogénéité
**** Principe de séparation
**** Principe de concision
*** peut être remplacée par : 
**** Principes 
***** Homogéneité
***** Séparation
***** Concision
----
=SANDBOX= 
phrase dont une partie est {{mise en évidence}} car elle représente un élément technique
phrase contenant un [[pragmaticmemory/lien|lien]] hypertexte.
exemple de liste :
* item 1 du niveau 1 
** item 1 du niveau 2 
*** item 1 du niveau 3
*** item 2 du niveau 3
** item 2 du niveau 2
* item 2 du niveau 1

----
=POWERSHELL= 
==Notation de types== 
* {{file}} : correspond à un fichier ({{FileInfo}}) ou un répertoire ({{DirectoryInfo}})
* {{string}} : une chaîne de caractères. La nature de l'objet représenté est indiqué entre parenthèses (path par exemple)
* {{file set}} : un ensemble de {{file}} passé sur le pipe
* {{string set}} : un ensemble de chaînes de caractères passé sur le pipe
* {{string list}} : une liste de chaînes caractères séparées par des ,
* {{object}} : un objet au sens large
==Compatibilité entre types== 
|| **Type attendu** || **Type particulier utilisable** ||
|| {{file set}} || {{file}} ||
|| {{string set}} || {{string}} ||
|| {{string list}} || {{string}} ||
|| {{object}} || {{tout type d'objet}} ||
==Membres par type== 
* Objet de type {{file}} :
|| {{BaseName}} || nom du fichier sans son extension ||
|| {{Extension}} || extension du fichier ||
|| {{FullName}} || nom complet du fichier (avec son path) ||
|| {{Name}} || nom du fichier avec son extension ||
|| {{PSParentPath}} || nom du répertoire parent ||
==Template des commandes== 
* __objectif de la commande__
{{type d'entrée 1 > <span style="background-color: #a5ddf8;">commande 1</span> > type de sortie 1}}
{{type d'entrée 2 > <span style="background-color: #a5ddf8;">commande 2</span> > type de sortie 2}}
Alias :
** {{alias 1}}
** {{alias 2}}
** {{alias 3}}
Options :
** {{option 1}} ({{shortcut 1}})
** {{option 2}} ({{shortcut 2}})
Remarques :
** remarque 1
** remarque 2
==IO== 
* __lister tous les éléments (fichiers et répertoires) d'un répertoire donné__
{{directory path > <span style="background-color: #a5ddf8;">Get-ChildItem -r "...</span> > file set}}
{{directory path > <span style="background-color: #a5ddf8;">$dir="...";Get-ChildItem -r $dir</span> > file set}}
Alias :
** {{dir}}
** {{ls}}
Options :
** {{-recurse}} ({{-r}})
* __lire le contenu d'un fichier__
{{string (path) list > <span style="background-color: #a5ddf8;">Get-Content(...)</span> > string set}}
{{string (path) list > <span style="background-color: #a5ddf8;">Get-Content(...)</span> > file list}}
* __récupérer un file set à partir d'une liste de path__
{{string (path) list > <span style="background-color: #a5ddf8;">Get-Content(...)</span> > file}}
* __écrire dans un fichier__
{{object, string (path) > <span style="background-color: #a5ddf8;">... | Out-File -filepath "..."</span> > file}}
Options :
** {{-append}} ({{permet de compléter un fichier déjà existant}})
** {{-inputObject}} ({{permet de préciser un objet à écrire}})
==Filtrage== 
* __ne conserver que les répertoires d'un file set (et pas les fichiers)__
{{file set > <span style="background-color: #a5ddf8;">... | where {$_.PsIsContainer}</span> > file set}}
* __ne conserver que les fichiers d'un file set (et pas les répertoires)__
{{file set > <span style="background-color: #a5ddf8;">... | where {!$_.PsIsContainer}</span> > file set}}
* __ne conserver que les entrées qui correspondent à une expression régulière__
{{string set, regular expression > <span style="background-color: #a5ddf8;">... | where {$_ -match "..."}</span> > string set}}
==Boucle== 
* __effectuer un même traitement sur un ensemble de données__
{{string set + commande powershell > <span style="background-color: #a5ddf8;">... | Foreach{...}</span> > string set (si écriture par la commande)}}
{{file set + commande powershell > <span style="background-color: #a5ddf8;">... | Foreach{...}</span> > string set (si écriture par la commande)}}
Remarques :
** Au début du Foreach, créer les variables qui seront utilisées dans la commande
** l'expression {{$_}} désigne l'entrée courante du {{string set}}
** plusieurs sous-commandes peuvent être séparées par un {{;}}
==Pipeline== 
* __écrire un objet sur le pipeline__
{{objet > <span style="background-color: #a5ddf8;">Write-Output(...)</span> > objet}}
==Information sur les objets== 
* __connaître le type et les membres d'un objet__
{{objet > <span style="background-color: #a5ddf8;">... | Get-Member</span> > MemberDefinition}}
* __lister les noms d'un ensemble de fichiers__
{{file set > <span style="background-color: #a5ddf8;">... | Foreach{$_.FullName}</span> > string set}}
{{file set > <span style="background-color: #a5ddf8;">... | Foreach{$_.Name}</span> > string set}}
==Exemples== 
* copie de tous les fichiers contenus dans le répertoire "C:\Temp\PS", avec ajout de BEGIN sur la première ligne et de END sur la dernière lignes 
** sans utilisation de pipe au sein du Foreach :
[[code format="powershell"]]
 Get-ChildItem -r "C:\Temp\PS" | where {!$_.PsIsContainer} | Foreach{$input=$_.FullName;$output=$_.PSParentPath+"\"+$_.BaseName+".copie.txt";$output;$content=Get-Content($input);Out-File -filePath "$output" -inputObject "BEGIN";Out-File -append -filePath "$output" -inputObject $content;Out-File -append -filePath "$output" -inputObject "END"}
[[code]]
** avec utilisation de pipe au sein du Foreach :
[[code format="powershell"]]
 Get-ChildItem -r "C:\Temp\PS" | where {!$_.PsIsContainer} | Foreach{$input=$_.FullName;$output=$_.PSParentPath+"\"+$_.BaseName+".copie.txt";$content=Get-Content($input);Write-Output("BEGIN", $content, "END")}
[[code]]
** variante avec utilisation du caractère d'échappemnt `r signifiant un retour à la ligne :
[[code format="powershell"]]
 Get-ChildItem -r "C:\Temp\PS" | where {!$_.PsIsContainer} | Foreach{$input=$_.FullName;$output=$_.PSParentPath+"\"+$_.BaseName+".copie.txt";$output;$content=Get-Content($input);$outputContent="BEGIN`r"+$content+"`rEND";Out-File -filePath "$output" -inputObject "$outputContent"}
[[code]]
----
=FILE MODIFICATIONS= 
L'objectif de cette section est de donner des méthodes de modification de fichiers. Elle détaille les outils utilisés, ainsi que les commandes au sein de ces outils.
==Fin de lignes dans les fichiers== 
* Caractères pouvant intervenir dans la séquence indiquant une fin de ligne 
** Carriage return (CR): {{\r}}
** Line feed (LF) : {{\n}}
* Séquences de caractères indiquant une fin de ligne 
** sous UNIX : {{\n}}
** sous Windows : {{\r\n}}
** sous Mac : {{\r}}
==Catalogue des méthodes de modifications== 
* Convertir les fins de ligne d'un fichier (Windows/Unix/Mac) 
** Notepad++ 
*** vers UNIX : Edition > Convertir les sauts de ligne > Convertir en Format UNIX (LF)
*** vers Windows : Edition > Convertir les sauts de ligne > Convertir en Format Windows (CR+LF)
*** vers Mac : Edition > Convertir les sauts de ligne > Convertir en Format Mac (CR)
* Voir les séquences de fin de ligne 
** Notepad++ 
*** Affichage > Symboles spéciaux > Afficher les symboles de fin de ligne
* Voir les blancs et les tabulations 
** Notepad++ 
*** Affichage > Symboles spéciaux > Afficher les blancs et les tabulations
* Supprimer des lignes vides (i.e ne contenant aucun caractère, pas même des espaces) 
** Notepad++ 
*** plugin TextFX : TextFX > TextFX Edit > Delete Blank Lines
* Compacter des lignes vides consécutives en une seule ligne vide 
** Notepad++ 
*** plugin TextFX : TextFX > TextFX Edit > Delete Surplus Blank Lines (mais comportement étrange avec les lignes contenant uniquement des espaces)
* Distribuer sur différentes lignes des items faisant partie d'une liste
|| **Source** || **Cible** ||
|| 
[[code]]
 A, B, C
[[code]] || 
[[code]]
 A

 B
 C
[[code]] ||
** Notepad++ 
*** remplacer ({{CTRL + H}})
*** mode étendu ({{\n}}, {{\r}}, {{\t}}, {{\0}}, {{\x}}...)
*** recherche : {{,}}
*** remplacer par : {{\r\n}}
* Assembler différentes lignes en une liste
|| **Source** || **Cible** ||
|| 
[[code]]
 A

 B
 C
[[code]] || 
[[code]]
 A, B, C
[[code]] ||
** Notepad++ 
*** remplacer ({{CTRL + H}})
*** mode étendu ({{\n}}, {{\r}}, {{\t}}, {{\0}}, {{\x}}...)
*** recherche : {{\r\n}}
*** remplacer par : {{,}}
* Trier des lignes en supprimant les doublons 
** Notepad++ (plugin TextFX) 
*** Notepad++TextFX > TextFX Tools > cocher "+Sort outputs only UNIQUE (at column) lines"
*** Notepad++TextFX > TextFX Tools > cocher "+Sort ascending" pour un tri par ordre alphabétique / décocher pour un ordre inverse
*** Notepad++TextFX > TextFX Tools > cliquer sur "Sort lines case sensitive (at column)" ou sur "Sort lines case insensitive (at column)"
* Indenter les xml 
** IntelliJ 
*** Code > Reformat Code...
*** Raccourci par défaut : CTRL + ALT + L
*** Fonctionne sur tous les fichiers du projet ou sur un ensemble de fichiers sélectionnés.
* Convertir "underscore" vers "camelcase"
|| **Source** || **Cible** ||
|| iinvCEqSector || IINV_C_EQ_SECTOR ||
** Notepad++ 
*** étape 1 : remplacer l'expression régulière ([A-Z]) par _\1 (cocher Respecter la casse)
*** étape 2 : passer en majuscule (CTRL + SHIFT + U)
* Comparer 2 listes 
** Excel 
*** en A1, saisir le formattage conditionnel [[pragmaticmemory/code|code]]
=ET(NON(ESTVIDE(A1)); NB.SI($B$1:$B$10000; A1)=0)
[[code]]
*** en B1, saisir le formattage conditionnel [[code]]

 =ET(NON(ESTVIDE(B1)); NB.SI($A$1:$A$10000; B1)=0)
[[code]]
*** copier le format de A1 sur la colonne A
*** copier le format de B1 sur la colonne B
*** Equivalence français / anglais : NB.SI / COUNTIF, ESTVIDE / ISBLANK, NON / NOT, ET / AND
*** Inspiré de l'article [[http://www.techrepublic.com/blog/msoffice/use-conditional-formatting-to-compare-lists-in-excel/4310]]
** sous UNIX : {{\n}}
** sous Windows : {{\r\n}}
** sous Mac : {{\r}}
=SUBVERSION= 
* Différences entre le working directory et la base
[[code]]
 svn diff
[[code]]
* Différences entre le working directory et le serveur
[[code]]
 svn diff -r HEAD
[[code]]
* Résumé des modifications locales
[[code]]
 svn status
[[code]]
* "Nettoyage" du working directory
[[code]]
 svn cleanup
[[code]]
* Informations sur le repository (branche, numéro de révision)
[[code]]
 svn info
[[code]]
----
=SQL= 
* sélectionner le maximum d'une colonne en fonction d'une autre colonne 
** Exemple :
[[code format="sql"]]
 create table max_test(code varchar(3), value int)

 insert into max_test(code, value) values ('A', 3)

 insert into max_test(code, value) values ('A', 4)

 insert into max_test(code, value) values ('A', 5)

 insert into max_test(code, value) values ('B', 1)

 insert into max_test(code, value) values ('B', 4)

 insert into max_test(code, value) values ('C', 7)

 insert into max_test(code, value) values ('C', 6)

 insert into max_test(code, value) values ('C', 5)
[[code]]
** Requête :
[[code format="sql"]]
 select code, max(value) from max_test group by code
[[code]]
* écrire un case dans un select 
** Exemple :
[[code format="sql"]]
 case

 when condition_1 then value_1

 when condition_2 then value_2

 ...

 when condition_n then value_n

 else value_else

 end
[[code]]
** Requête :
[[code format="sql"]]
 select code, max(value) from max_test group by code
[[code]]
----
=SYBASE= 
* Vérifier l'existence d'une table
[[code format="sql"]]
 select 1 from sysobjects where type = 'U' and name = 'nom_de_table'
[[code]]
* Vérifier l'existence d'une procédure stockée
[[code format="sql"]]
 select 1 from sysobjects where type = 'P' and name = 'nom_de_procedure'
[[code]]
* Vérifier l'existence d'une table temporaire
[[code format="sql"]]
 select 1 from tempdb..sysobjects where substring(name, 1, len('#INDEX_LIST')) = '#INDEX_LIST' and type = 'U'
[[code]]
* Déclarer une variable
[[code format="sql"]]
 declare @nom_de_la_variable type_de_la_variable
[[code]]
** example : {{declare @ptf_cod varchar(12)}}
* Affecter une valeur à une variable
[[code format="sql"]]
 select @nom_de_la_variable = @valeur_de_la_variable
[[code]]
** example : {{select @ptf_cod = 'ZX23'}}
* Voir le code d'une procédure stockée
[[code format="sql"]]
 sp_helptext 'nom_de_procedure'
[[code]]
* Obtenir la liste des utilisateurs
[[code format="sql"]]
 sp_helpuser
[[code]]
* Obtenir la liste des groupes
[[code format="sql"]]
 sp_helpgroup
[[code]]
* Ajouter à une base un groupe défini sur le data serveur
[[code format="sql"]]
 sp_addgroup 'nom_de_groupe'
[[code]]
==Le fichier {{sql.ini}}== 
Les adaptive server (également appelés data server dans cette page, par opposition aux serveurs physiques) sont définis dans le fichier {{sql.ini}} ( présent par exemple dans {{C:\Program Files\sybase\12.5.1\ini}}) Ils sont définis suivant le template :
[[code]]
 [DATA_SERVEUR_NAME]

 query=TCP,server-name,port
[[code]]
où server-name est le nom ou l'alias d'une machine. Remarques :
** un data serveur peut héberger plusieurs bases
** si {{A}} et {{B}} sont 2 bases sur un même data server, et si {{a}} est un objet de {{A}} et {{b}} un objet de {{B}}, {{a}} peut référencer {{b}} en utilisant la syntaxe {{B..b}}
==L'outil {{isql}}== 
Outil Sybase permettant l'exécution d'un script sql via la syntaxe
[[code]]
 isql -UUSER -PPASSWORD -SDATA_SERVER -DBASE -i C:\Temp\sql\script.sql
[[code]]
Remarques :
** Le fichier d'entrée (ex: {{script.sql}}) passé à {{isql}} peut inclure un fichier (ex : {{include.sql}}) à l'aide de la syntaxe :
[[code]]
 :r C:\Temp\include.sql
[[code]]
** il ne doit pas y avoir d'espace entre le début de la ligne et le {{:r}}
----
=DOS= 
* Lister récursivement les fichiers d'un répertoire
[[code format="dos"]]
 dir /S /A:-D /B
[[code]]
* {{/S}} (subdirectories) :permet la récursion sur les sous-répertoires
* {{/A}} (attribute) :{{-D}} : ne possédant pas l'attribut "Directory"
* {{/B}} (bare format (format nu)) :présente seulement les noms de fichiers sans formattage
----
=KEYBOARD= 
* Basculer entre anglais et français : ALT + SHIFT
----
=REGULAR EXPRESSIONS= 
==IntelliJ== 
* {{\t}} : matche avec les tabulations
* {{\r}} : non reconnu
* {{\n}} : matche avec la séquence de fin de ligne ({{\r\n}} sous Windows et {{\n}} sous Unix)
* Expression désignant le premier groupe capturé : {{$1}}
==Notepad++== 
* {{\t}} : matche avec les tabulations
* {{\r}} : non reconnu
* {{\n}} : non reconnu
* Expression désignant le premier groupe capturé : {{\1}}
----
=Anglais= 
==Références== 
* phonétique : [[http://www.wordreference.com/|http://www.wordreference.com]]
* traduction : [[http://www.wordreference.com/|http://www.wordreference.com]]
* Liste des symboles phonétiques : [[http://www.wordreference.com/fr/French-Pronunciation.aspx]]
* ipa : [[http://www.antimoon.com/how/pronunc-soundsipa.htm]]
==Liste== 
|| **Mot** || **Phonétique** || **Description** ||
|| comfort || ['k?mf?t] || confort ||
|| comfortable || ['k?mft?bl, US :'k?mf?rtbl] || confortable ||
|| database || ['de?t??be?s] || base de données ||
|| flaccid || ['flæks?d / 'flæs?d] || flasque, mou ||
|| pawn || [p??n] || pions (aux échecs) ||
----
=Français= 
==Références== 
* Définition : [[http://www.lexilogos.com/francais_langue_dictionnaires.htm]]
==Liste== 
|| **Mot** || **Description** ||
|| atermoiement || (souvent au pluriel) action de différer, retarder; hésitation, tergiversation ||
----
=WEB AND WIKI= 
* Créer son wiki : [[http://fr.mashable.com/2008/07/30/30-solutions-pour-creer-votre-propre-wiki]]
* Créer son site web : [[http://www.2createawebsite.com/|http://www.2createawebsite.com]]
----
=XML TECHNO= 
==XSLT== 
* Testeurs Xslt online 
** mark bucayan : [[http://markbucayan.appspot.com/xslt/index.html]]
** xslt cake : [[http://www.xsltcake.com/|http://www.xsltcake.com]]
* Tutoriaux Xslt 
** Article sur les node set intermédiaires (utilisé pour l'imbrication de formatages comme élément de liste souligné) : [[http://xmlfr.org/documentations/faq/041013-0001]]
** Traitement des espaces blancs : décrire la problèmatique en citant le livre "XSLT Fondamental" de Philippe Drix, aux éditions Eyrolles. : [[#]]
==XSD / DTD== 
* Tutoriaux XSD 
** Tutorial Xsd 1 : [[http://www.codeproject.com/Articles/18426/XSD-Tutorial-Part-1-of-5-Elements-and-Attributes]]
** Tutorial Xsd 2 : [[http://www.w3schools.com/schema/default.asp]]
** DTD et XSD : [[http://gilles-chagnon.developpez.com/cours/xml/dtd-et-schemas]]
* Validateur XSD online 
** Xsd online validator : [[http://www.corefiling.com/opensource/schemaValidate.html]]
----
=JAVA= 
==Lire les lignes d'un fichier== 
* java.lang : String,
* java.util : List, ArrayList,
[[code format="java"]]
 public static ListString readLines(File file) throws IOException {

 BufferedReader reader = new BufferedReader(new FileReader(file));

 ListString lines = new ArrayListString();

 String line = reader.readLine();

 while (line != null) {

 lines.add(line);

 line = reader.readLine();

 }

 reader.close();

 return lines;

 }
[[code]]
Remarques :
* Pour deux fichiers contenant respectivement {{A\r\nB}} et {{A\r\nB\r\n}}, la méthode {{readLines}} renvoie une liste identique (contenant les 2 éléments {{A}} et {{B}}).
==Insérer des lignes dans un fichier== 
* java.lang : String,
* java.util : List,
* java.io : FileWriter, BufferedWriter,
[[code format="java"]]
 public static void writeLines(ListString lines, File file) throws IOException {

 BufferedWriter writer = new BufferedWriter(new FileWriter(file));

 for (int i = 0; i  lines.size() - 1; i++) {

 writer.write(lines.get(i));

 writer.newLine();

 }

 writer.write(lines.get(lines.size() - 1));

 writer.flush();

 writer.close();

 }
[[code]]
Remarques :
* la méthode {{writeLines}} n'ajoute pas de séquence de fin de ligne après la dernière ligne
==Manipuler les listes== 
* java.lang : String,
* java.util : List, ArrayList, Arrays,
[[code format="java"]]
 SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");

 Date date = sdf.parse("10/11/2011");
[[code]]
==Récupérer les propriétés systèmes== 
* java.lang : System,
[[code format="java"]]
 System.getProperties()
[[code]]
==Récupérer une liste fixe de chaînes de caractères== 
* java.lang : String,
* java.util : List, ArrayList,
[[code format="java"]]
 public ListString getAllFilePath() {

 String[] pathArray = {

 "C:\\dev\\file1.xml",

 "C:\\dev\\file2.txt"

 };

 ListString stringList = new ArrayListString();

 stringList.addAll(Arrays.asList(pathArray));

 return stringList;

 }
[[code]]
==Modifier plusieurs fichiers== 
[[code format="java"]]
 public void process() throws Exception {

 for (String filePath : getAllFilePath()) {

 File file = new File(filePath);

 ListString lines = readLines(file);

 ListString processedLines = process(lines);

 writeLines(processedLines, file);

 }

 }
[[code]]
Remarques :
* {{getAllFilePath}}, {{readLines}}, {{writeLines}} sont 3 méthodes définies dans cette section
* La méthode {{process}}est la seule qui reste à définir
* D'après les remarques sur les méthodes {{readLines}} et {{writeLines}}, la lecture puis la réécriture d'un fichier se terminant par une séquence de fin de ligne aura pour conséquence la suppression de cette séquence
==Utiliser les expressions régulières== 
* java.util.regex : Pattern, Matcher,
[[code format="java"]]
 public static void main(String[] args) {

 Pattern pattern = Pattern.compile("(\\w)(..)(.)");

 Matcher matcher = pattern.matcher("abcd efghijklmn");

 while (matcher.find()) {

 System.out.println("MATCH !");

 System.out.println("group()= " + matcher.group());

 System.out.println("offset before first matched character = " + matcher.start());

 System.out.println("offset after last matched character= " + matcher.end());

 System.out.println("groupCount = " + matcher.groupCount());

 for (int i = 0; i  matcher.groupCount() + 1; i++) {

 System.out.println("\tgroup(" + i + ") = " + matcher.group(i));

 System.out.println("\t\toffset before group(" + i + ") first character= " + matcher.start(i));

 System.out.println("\t\toffset after group(" + i + ") last character = " + matcher.end(i));

 }

 }

 System.out.println("modifiedString = " + matcher.replaceAll("X"));

 }
[[code]]
Remarques :
* L'éxécution du code précédent affiche la sortie suivante :
[[code]]
 MATCH !

 group()= abcd

 offset before first matched character = 0

 offset after last matched character= 4

 groupCount = 3

 group(0) = abcd

 offset before group(0) first character= 0

 offset after group(0) last character = 4

 group(1) = a

 offset before group(1) first character= 0

 offset after group(1) last character = 1

 group(2) = bc

 offset before group(2) first character= 1

 offset after group(2) last character = 3

 group(3) = d

 offset before group(3) first character= 3

 offset after group(3) last character = 4

 MATCH !

 group()= efgh

 offset before first matched character = 5

 offset after last matched character= 9

 groupCount = 3

 group(0) = efgh

 offset before group(0) first character= 5

 offset after group(0) last character = 9

 group(1) = e

 offset before group(1) first character= 5

 offset after group(1) last character = 6

 group(2) = fg

 offset before group(2) first character= 6

 offset after group(2) last character = 8

 group(3) = h

 offset before group(3) first character= 8

 offset after group(3) last character = 9

 MATCH !

 group()= ijkl

 offset before first matched character = 9

 offset after last matched character= 13

 groupCount = 3

 group(0) = ijkl

 offset before group(0) first character= 9

 offset after group(0) last character = 13

 group(1) = i

 offset before group(1) first character= 9

 offset after group(1) last character = 10

 group(2) = jk

 offset before group(2) first character= 10

 offset after group(2) last character = 12

 group(3) = l

 offset before group(3) first character= 12

 offset after group(3) last character = 13

 modifiedString = X XXmn
[[code]]
==Décompiler des classes java== 
* Solution : utiliser l'outil {{JD-GUI}} ([[http://java.decompiler.free.fr/?q=jdgui]])

----